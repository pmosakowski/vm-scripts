#!/usr/bin/env python2

import argparse, logging
import os, os.path
import csv, io
from collections import namedtuple

import guestfs

loglevels = { 'debug' : logging.DEBUG,
              'info' : logging.INFO,
              'warn' : logging.WARNING}

class ParseLoglevel(argparse.Action):
    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        if nargs is not None:
            raise ValueError("nargs not allowed")
        super(ParseLoglevel, self).__init__(option_strings, dest, **kwargs)
    def __call__(self, parser, namespace, values, option_string=None):
        loglevel = self.parse_loglevel(values)
        setattr(namespace, self.dest, loglevel)
    def parse_loglevel(self, loglevel_string):
        try:
            return loglevels[loglevel_string]
        except:
            msg = '{} is not a supported loglevel'.format(loglevel_string)
            raise argparse.ArgumentTypeError(msg)

User = namedtuple('User', ['uid','gid','home'])
def parse_etc_passwd(file_contents):
    mem_file = io.BytesIO(file_contents)
    passwdreader = csv.reader(mem_file, delimiter=':')
    users = {}
    for row in passwdreader:
        username = row[0]
        uid = int(row[2])
        gid = int(row[3])
        home = row[5]
        if uid >= 1000:
            users[username] = User(uid=uid, gid=gid, home=home)
    return users

parser = argparse.ArgumentParser(description='Add your SSH public keys to a user on a virtual machine disk')
parser.add_argument('image', metavar='DISK_IMAGE', type=str, help='name of the target disk image')
parser.add_argument('-l','--loglevel', help='log message verbosity', default=logging.WARNING, choices=loglevels, action=ParseLoglevel)

args = parser.parse_args()

cwd = os.getcwd()
log = logging.getLogger(__name__)
log.addHandler(logging.StreamHandler())
log.setLevel(args.loglevel)
log.debug('[HOST] current working directory %s', cwd)

user = os.environ['USER']
log.debug('[HOST] running as user %s', user)

home = os.environ['HOME']
ssh_dir = os.path.join(home, '.ssh')
log.debug('[HOST] looking for keys in %s',ssh_dir)

rsa_key = os.path.join(ssh_dir, 'id_rsa.pub')
dsa_key = os.path.join(ssh_dir, 'id_dsa.pub')
key_strings = []
for key_file in [rsa_key, dsa_key]:
    if os.path.isfile(key_file):
        log.info('[HOST] found public key %s', key_file)
        with open(key_file,'r') as public_key:
            key_strings.append(public_key.read().strip())

authorized_keys = '\n'.join(key_strings)

log.debug('[HOST] list of collected keys:\n%s', authorized_keys)

image_path = os.path.normpath(os.path.join(cwd,args.image))
if not os.path.isfile(image_path):
    log.error('[HOST] image %s does not exists, is not accessible or not a regular file', image_path)
    exit(1)

log.info('[HOST] modifying image %s', image_path)

gfs = guestfs.GuestFS(python_return_dict=True)

gfs.add_drive(args.image)
gfs.launch()
gfs.mount('/dev/sda2','/')

etc_passwd = gfs.cat('/etc/passwd')
users = parse_etc_passwd(etc_passwd)
print(users)

if not gfs.exists(users['mosaq'].home):
    log.error('[GUEST] user\'s home directory %s cannot be found, possibly it\'s on another partition', users['mosaq'].home)

if not gfs.is_dir(ssh_dir):
    log.info('[GUEST] creating directory %s', ssh_dir)
    gfs.mkdir_mode(ssh_dir,0700)
else:
    log.info('[GUEST] directory %s present', ssh_dir)

gfs.chown(users['mosaq'].uid, users['mosaq'].gid, ssh_dir)

authorized_keys_file = os.path.join(ssh_dir,'authorized_keys')
if gfs.is_file(authorized_keys_file):
    log.info('[GUEST] file %s present, removing', authorized_keys_file)
    gfs.rm(authorized_keys_file)

log.info('[GUEST] creating file %s', authorized_keys_file)
gfs.write(authorized_keys_file,authorized_keys)

gfs.chmod(0600, authorized_keys_file)
gfs.chown(users['mosaq'].uid, users['mosaq'].gid, authorized_keys_file)
