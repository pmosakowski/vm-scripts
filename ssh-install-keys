#!/usr/bin/env python2

import argparse, logging
import os, os.path
import csv, io
from collections import namedtuple
import re

import guestfs

class ParseLoglevel(argparse.Action):
    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        if nargs is not None:
            raise ValueError("nargs not allowed")
        # 'choices' dictionary provided as argument to add_argument()
        # is used both in validation of string values and conversion
        # to loglevel constant
        if len(kwargs['choices']) is 0:
            raise ValueError("dict with valid logging choices must be provided")
        self.loglevels = kwargs['choices']
        super(ParseLoglevel, self).__init__(option_strings, dest, **kwargs)
    def __call__(self, parser, namespace, values, option_string=None):
        loglevel = self.parse_loglevel(values, self.loglevels)
        setattr(namespace, self.dest, loglevel)
    def parse_loglevel(self, loglevel_string, loglevels):
        try:
            return loglevels[loglevel_string]
        except:
            msg = '{} is not a supported loglevel'.format(loglevel_string)
            raise argparse.ArgumentTypeError(msg)

User = namedtuple('User', ['uid','gid','home'])
def parse_etc_passwd(file_contents):
    mem_file = io.BytesIO(file_contents)
    passwdreader = csv.reader(mem_file, delimiter=':')
    users = {}
    for row in passwdreader:
        username = row[0]
        uid = int(row[2])
        gid = int(row[3])
        home = row[5]
        if uid >= 1000:
            users[username] = User(uid=uid, gid=gid, home=home)
    return users

class Configurator:
    def __init__(self):
        self.loglevels = { 'debug' : logging.DEBUG,
                      'info' : logging.INFO,
                      'warn' : logging.WARNING}

        self.parser = argparse.ArgumentParser(description='Add your SSH public keys to a user on a virtual machine disk')

        operation = self.parser.add_mutually_exclusive_group()
        append_help = 'if file \'authorized_keys\' exists keys will be appended to it (if' \
                      'not present already), otherwise the file will be created'
        operation.add_argument('-a', '--append', help=append_help, action='store_true')

        replace_help  = 'if file \'authorized_keys\' exists it will be removed and a new' \
                        'file will be created. This is the default operation'
        operation.add_argument('-r', '--replace', help=replace_help, action='store_true')

        delete_help = 'if file \'authorized_keys\' exists it will be removed'
        operation.add_argument('-d', '--delete', help=delete_help, action='store_true')

        self.parser.add_argument('image', metavar='DISK_IMAGE', type=str, help='name of the target disk image')
        self.parser.add_argument('-l','--loglevel', help='log message verbosity', default=logging.WARNING, choices=self.loglevels, action=ParseLoglevel)

    def __parse_commandline(self):
        self.args = self.parser.parse_args()
        self.image = self.args.image
        self.loglevel = self.args.loglevel

    def __setup_logging(self):
        self.log = logging.getLogger(__name__)
        self.log.addHandler(logging.StreamHandler())
        self.log.setLevel(self.loglevel)

    def __load_env_vars(self):
        self.cwd = os.getcwd()
        self.log.debug('[HOST] current working directory %s', self.cwd)

        self.user = os.environ['USER']
        self.log.debug('[HOST] running as user %s', self.user)

        self.host_home = os.environ['HOME']
        self.host_ssh_dir = os.path.join(self.host_home, '.ssh')
        self.log.debug('[HOST] looking for keys in %s', self.host_ssh_dir)

    def configure(self):
        self.__parse_commandline()
        self.__setup_logging()
        self.__load_env_vars()

        self.image_path = os.path.normpath(os.path.join(self.cwd, self.image))
        if not os.path.isfile(self.image_path):
            self.log.error('[HOST] image %s does not exists, is not accessible or not a regular file', self.image_path)
            exit(1)
        else:
            self.log.info('[HOST] modifying image %s', self.image_path)

# Class for inspecting the disk image that will tell us the relevant information
class Inspector:
    def __init__(self, guestfs_handle, config):
        self.gfs = guestfs_handle
        self.config = config
        self.log = self.config.log
        self.__inspect()

    def __inspect(self):
        os_list = self.gfs.inspect_os()
        assert(len(os_list) == 1)
        self.root_fs = os_list[0]
        self.log.info('[GUEST] found root filesystem %s', self.root_fs)

        self.mountpoints = self.gfs.inspect_get_mountpoints(self.root_fs)
        for mount,part in self.mountpoints.iteritems():
            self.log.debug('[GUEST] found partition %s : %s', mount, part)

def mount_fs_tree(gfs, mountpoints, config):
    for mountpoint in sorted(mountpoints.keys()):
        partition = mountpoints[mountpoint]
        gfs.mount(partition, mountpoint)
        config.log.info('[GUEST] mounting partition %s : %s', mountpoint, partition)

def get_ssh_keys(config):
    rsa_key = os.path.join(config.host_ssh_dir, 'id_rsa.pub')
    dsa_key = os.path.join(config.host_ssh_dir, 'id_dsa.pub')
    keys = {}
    for key_path in [rsa_key, dsa_key]:
        if os.path.isfile(key_path):
            config.log.info('[HOST] found public key %s', key_path)
            with open(key_path,'r') as key_file:
                keys[key_path] = key_file.read().strip()

    return keys

# Here start commands that create new authorized_keys file on host
# replacing the old one if present
def replace_keys(gfs, config):
    authorized_keys = '\n'.join(get_ssh_keys(config).values())
    config.log.debug('[HOST] list of collected keys:\n%s', authorized_keys)


    inspect = Inspector(gfs, config)

    mount_fs_tree(gfs, inspect.mountpoints, config)

    etc_passwd = gfs.cat('/etc/passwd')
    users = parse_etc_passwd(etc_passwd)
    print(users)

    guest_home = users['mosaq'].home
    if not gfs.exists(guest_home):
        config.log.error('[GUEST] user\'s home directory %s cannot be found, possibly it\'s on another partition', users['mosaq'].home)
    else:
        guest_ssh_dir = os.path.join(guest_home, '.ssh')

    if not gfs.is_dir(guest_ssh_dir):
        config.log.info('[GUEST] creating directory %s', guest_ssh_dir)
        gfs.mkdir_mode(guest_ssh_dir,0700)
    else:
        config.log.info('[GUEST] directory %s present', guest_ssh_dir)
        gfs.chmod(0700, guest_ssh_dir)

    gfs.chown(users['mosaq'].uid, users['mosaq'].gid, guest_ssh_dir)

    authorized_keys_file = os.path.join(guest_ssh_dir,'authorized_keys')
    if gfs.is_file(authorized_keys_file):
        config.log.info('[GUEST] file %s present, removing', authorized_keys_file)
        gfs.rm(authorized_keys_file)

    config.log.info('[GUEST] creating file %s', authorized_keys_file)
    gfs.write(authorized_keys_file,authorized_keys)

    gfs.chmod(0600, authorized_keys_file)
    gfs.chown(users['mosaq'].uid, users['mosaq'].gid, authorized_keys_file)

    def find_guest_executable(executable_name):
        guest_filelist = gfs.find('/')
        rc_regex = re.compile('^.+/{}$'.format(executable_name))
        for file_path in guest_filelist:
            match = rc_regex.match(file_path)
            if match:
                executable = os.path.join('/',match.group(0))
                config.log.debug('[GUEST] found executable %s', executable)
                return executable

    config.log.info('[GUEST] restoring SELinux context on %s', authorized_keys_file)
    restorecon = find_guest_executable('restorecon')
    load_policy = find_guest_executable('load_policy')

    load_policy_output = gfs.sh(load_policy)
    config.log.debug('[GUEST] %s[%i] : %s', load_policy, len(load_policy_output), load_policy_output)
    restorecon_output = gfs.sh(restorecon + " " + authorized_keys_file)
    config.log.debug('[GUEST] %s[%i] : %s', restorecon, len(restorecon_output), restorecon_output)

def delete_keys(gfs, config):
    config.log.info('[HOST] selected operation \'delete\'')
    inspect = Inspector(gfs, config)
    mount_fs_tree(gfs, inspect.mountpoints, config)

config = Configurator()
config.configure()

operations = {
        'replace' : replace_keys,
        'delete' : delete_keys, }

operation = operations['delete']

gfs = guestfs.GuestFS(python_return_dict=True)
gfs.add_drive(config.image_path)
gfs.set_selinux(1)
gfs.launch()

operation(gfs, config)
